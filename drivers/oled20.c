/*
 * oled20.c
 *
 * Created: 11.09.20 13.19
 *  Author: eivin
 */ 
#include "oled20.h"
#include "fonts.h"

#include "i2c.h"

#define OLED_ADRESS 0b0111100

static uint8_t oled_buffer[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0xC0,0xC0,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,
0xFB,0xFB,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xC3,0xC3,0xC3,0xC3,0xC3,0xFF,0xFF,0xFF,0xFF,
0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x03,0x03,0xFF,0xFF,0xFF,0xFF,0x03,0x03,0xFF,0xFF,
0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,
0xF3,0xF3,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x03,0x03,0x03,0x03,
0x03,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3F,0x3F,0x3F,
0x3F,0x3F,0x00,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
0x3E,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x03,0x03,0x03,0x03,0x03,0x3F,0x3F,0x3F,0x3F,
0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x00,0x00,0x3F,0x3F,
0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x3C,0x3C,0x3C,0x3C,
0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x3C,0x3C,0x3C,0x3C,
0x3C,0x3F,0x3F,0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


//OLED FUNCTIONS

void oled_write_c(char data)
{
    uint8_t data_c[2];
    data_c[0] = 0b10000000;
    data_c[1] = data;
    i2c_sendNOADDR((uint8_t)OLED_ADRESS, (uint8_t *) &data_c, 2);
		
}
void oled_write_d(char data)
{
    uint8_t data_c[2];
    data_c[0] = 0b11000000;
    data_c[1] = data;
    i2c_sendNOADDR((uint8_t)OLED_ADRESS, (unsigned char *)&data_c, 2);
}

ret_code_t oled_init()
{
    oled_write_c(0xae); // Set display OFF		
 
    oled_write_c(0xd4); // Set Display Clock Divide Ratio / OSC Frequency
    oled_write_c(0x80); // Display Clock Divide Ratio / OSC Frequency 
 
    oled_write_c(0xa8); // Set Multiplex Ratio
    oled_write_c(0x3f); // Multiplex Ratio for 128x64 (64-1)
 
    oled_write_c(0xd3); // Set Display Offset
    oled_write_c(0x00); // Display Offset
 
    oled_write_c(0x40); // Set Display Start Line
 
    oled_write_c(0x8d); // Set Charge Pump
    oled_write_c(0x14); // Charge Pump (Internal DC/DC)
 
    oled_write_c(0xa1); // Set Segment Re-Map
    oled_write_c(0xc8); // Set Com Output Scan Direction
 
    oled_write_c(0xda); // Set COM Hardware Configuration
    oled_write_c(0x12); // COM Hardware Configuration
 
    oled_write_c(0x81); // Set Contrast
    oled_write_c(0xcf); // Contrast
 
    oled_write_c(0xd9); // Set Pre-Charge Period
    oled_write_c(0xf1); // Set Pre-Charge Period (Internal)
 
    oled_write_c(0xdb); // Set VCOMH Deselect Level
    oled_write_c(0x40); // VCOMH Deselect Level
 
    oled_write_c(0xa4); // Set all pixels OFF
    oled_write_c(0xa6); // Set display not inverted
    oled_write_c(0xaf); // Set display On
	
/*	//oled_write_c(0xa5);    //Set out follows RAM content
    oled_reset(); */
	return NRF_SUCCESS;
	
}

int buffer_line, buffer_column = 0; //used to keep track of current line and column
uint16_t buffer_index = 0;

void oled_reset()
{
	for (int i = 0; i<=7; i++)
	{
		oled_clear_line(i);
	}
	oled_pos(0,0);
}

void oled_home()
{
	oled_goto_line(0);
    oled_goto_column(0);
}

void oled_goto_line(int line)
{
	buffer_line = line;
	buffer_index = buffer_line*128 + buffer_column;
}

void oled_goto_column(int column)
{
	buffer_column = column;
	buffer_index = buffer_line*128 + buffer_column;
}

void oled_clear_line(int line)
{
	oled_pos(line,0);
	for (int i = 0; i < 128; i++)
	{
		oled_write_d(0);
	}	
}

void oled_pos(int row, int column)
{
	oled_goto_line(row);
	oled_goto_column(column);

}

void oled_print(char letter, int font_size)
{
	switch (font_size)
	{
		
		case 5:
			for (int i = 0; i < font_size;i++)
			{
				oled_buffer[buffer_index] = (char) font5[(int)letter - 32][i];
				buffer_index++;
			}
			break;
		
		default:
			return;
	}
}

void oled_print_string(char string[], int font_size, int start_line, int start_column)
{
	oled_goto_line(start_line);
	oled_goto_column(start_column);
	int current_line = start_line;
	int letters_per_line = OLED_PIXEL_WIDTH / font_size;
	int letters_written_on_line = 0;
	int current_letter = 0;
	while (string[current_letter] != '\0')
	{
		if(letters_written_on_line >= letters_per_line)
		{
			current_line++;
			letters_written_on_line = 0;
			if (current_line > 7)
			{
				return;
			}
			oled_goto_line(current_line);
		}
		oled_print(string[current_letter], font_size);
		letters_written_on_line++; 
		current_letter++;
	}
}

void oled_print_figure(char id, char start_line, int start_column)
{
	oled_goto_line(start_line);
	oled_goto_column(start_column);
	switch (id)
	{
		case 1:
		for(int j = 0; j < 3; j++)
		{
			oled_goto_line(start_line+j);
			oled_goto_column(start_column);
			for (int i = 0; i < 24;i++)
			{
				//oled_write_d((char) hilse[j][i]); 
				oled_buffer[buffer_index] = (char) hilse[j][i];
				buffer_index++; 
			}
		}
			break;
		case 3:
			oled_goto_line(start_line);
			oled_goto_column(start_column);
			for (int i = 0; i < 8; i++)
			{
				//oled_write_d((char) arrow[0][i]);  
				oled_buffer[buffer_index] = ((char) arrow[0][i]);
				buffer_index++; 
				
			}
			break;
		default:
			break;
	}
}

//Original functions rewritten to I2C
void oled_uninit(void)
{
    //
}

/**
 * @brief Function for drawing a single pixel in buffer
 *
 * Callback function for the nRF gfx/display driver/module. Note that pixels
 * are drawn in buffer, and not directly to OLED.
 *
 * @param x     X-position of pixel.
 * @param y     Y-position of pixel.
 * @param color Color of pixel, black or white.
 */
void oled_draw_pixel(uint16_t x, uint16_t y, uint32_t color) {
	ASSERT(x < OLED_WIDTH);
    ASSERT(y < OLED_HEIGHT);
	
	if (color == 1)
		oled_buffer[x + (y/8)*OLED_WIDTH] |= (1 << (y&7));
	else
		// oled_buffer[x + (y/8)*OLED_WIDTH] |= (1 << (y&7));
		oled_buffer[x + (y/8)*OLED_WIDTH] &= ~(1 << (y&7));

	// write to correct position in buffer, ref algorithm on paper
}

/**
 * @brief Function for drawing a rectangle in buffer.
 *
 * Callback function for the nRF gfx/display driver/module. Note that pixels
 * are drawn in buffer, and not directly to OLED. Algorithm is taken from
 * Nordic Semiconductor's library.
 *
 * @param x      Start X-position, lower left corner.
 * @param y      Start Y-position, lower left corner.
 * @param width  Width of rectangle.
 * @param height Color of pixel, black or white.
 * @param color  Color of rectangle, black or white.
 */
void oled_draw_rectangle(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color) {
	if ((x + width) >= OLED_WIDTH)
    {
        return;
    }
    if ((y + height) >= OLED_HEIGHT)
    {
        return;
    }
	
	for (uint8_t idx_y = y; idx_y < (y + height); idx_y++)
    {
        for (uint8_t idx_x = x; idx_x < (x + width); idx_x++)
        {
            oled_draw_pixel(idx_x, idx_y, color);
        }
    }
}

/**
 * @brief Function for outputting buffer to OLED.
 *
 * Callback function for the nRF gfx/display driver/module.
 */
void oled_display(void) {

	//Reset to top left corner
	for (int page = 0; page < OLED_PAGES; page++)
	{	
		oled_write_c(0xb0+page);
		oled_write_c(0x00);
		oled_write_c(0x10);
		for (int i = 0; i < OLED_WIDTH; i++)
		{
		oled_write_d(oled_buffer[page*128 + i]);
		}
	
	}
	
}

/**
 * @brief Function for clearing buffer.
 *
 * Callback function for the nRF gfx/display driver/module.
 */
void old_oled_clear(void) {
	memset((void *)oled_buffer, 0, sizeof(oled_buffer));
}

/**
 * @brief Function for setting rotation. (Not implemented).
 *
 * Callback function for the nRF gfx/display driver/module. Note that this
 * functions is optional, and unlikely to be useful in the SLAM project.
 * It is include here primarily as the nRF gfx library must be given a
 * callback function even if not used.
 */
void old_oled_dummy_rotation_set(nrf_lcd_rotation_t rotation) {
	// unnecessary for this application
}

/**
 * @brief Function for inverting OLED. (Not implemented).
 *
 * Callback function for the nRF gfx/display driver/module. Note that this
 * functions is optional It is include here primarily as the nRF gfx library
 * must be given a callback function even if not used.
 */
void oled_invert(bool invert) {
	// OLED has built-in invert command
	if(invert) 	oled_write_c(0xa7); 	// Set display 		inverted
	else 		oled_write_c(0xa6); 	// Set display not 	inverted

}